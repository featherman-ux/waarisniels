---
// src/pages/map.astro
import BaseLayout from '../layouts/BaseLayout.astro';

const pageTitle = "Kaart";
const pageDescription = "Eenvoudige kaart met mijn route en stops (bus, motor, vlucht).";
---

<BaseLayout title={pageTitle} description={pageDescription}>
  <style>
    :root { --orange:#ffb703; --blue:#023047; }
    header.hero{
      background:var(--orange); color:#fff; text-align:center;
      padding:3rem 1.5rem; margin-bottom:2rem; border-radius:0.75rem;
      box-shadow:0 4px 12px rgba(0,0,0,.1);
    }
    header.hero h1{font-size:2rem;margin:0 0 .5rem}
    header.hero p{margin:0;font-size:1rem;opacity:.95}
    .container{max-width:1100px;margin:0 auto;padding:0 1.5rem 2rem}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,.06);padding:1rem}
    .map-wrap{border-radius:12px;overflow:hidden;height:520px}
    .legend{
      display:flex;gap:.6rem .9rem;justify-content:center;align-items:center;
      color:#374151;font-size:.95rem;margin-top:.75rem;flex-wrap:wrap
    }
    .chip{background:#f8fafc;border:1px solid #e5e7eb;border-radius:9999px;padding:.25rem .6rem;font-size:.85rem}
    .chip .line{display:inline-block;vertical-align:middle;width:16px;height:0;border-top-width:3px;border-top-style:solid;margin-right:.4rem}
    .note{color:#6b7280;font-size:.9rem;text-align:center;margin-top:1rem}
  </style>

  <header class="hero">
    <h1>{pageTitle}</h1>
    <p>Kaart werkt!!!!!!</p>
  </header>

  <main class="container">
    <section class="card">
      <div class="map-wrap" id="map"></div>

      <!-- Legenda met drie modi -->
      <div class="legend">
        <span class="chip"><span class="line" style="border-color:#023047;border-top-style:solid;"></span>Bus</span>
        <span class="chip"><span class="line" style="border-color:#10b981;border-top-style:dotted;border-top-width:3px;"></span>Motor</span>
        <span class="chip"><span class="line" style="border-color:#ffb703;border-top-style:dashed;"></span>Vlucht</span>
        <span class="chip">Stops / steden</span>
      </div>
    </section>

   
  </main>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js" defer></script>

  <script is:inline>
    const ROUTE_URL  = "/data/route.geojson";
    const PLACES_URL = "/data/places.json";

    function ready(fn){document.readyState!=='loading'?fn():document.addEventListener('DOMContentLoaded',fn);}

    // OSRM demo endpoint: best-effort, rate-limited
    const OSRM_URL = "https://router.project-osrm.org/route/v1/driving";

    // Vervoersmodus → stijl
    function styleForMode(mode) {
      if (mode === 'flight') return { color: '#ffb703', weight: 4, opacity: 0.95, dashArray: '6 6' }; // oranje dashed
      if (mode === 'motor')  return { color: '#10b981', weight: 4, opacity: 0.95, dashArray: '2 8' };  // groen dotted
      return { color: '#023047', weight: 4, opacity: 0.95 }; // bus = blauw, solide
    }

    // Route over weg (OSRM). Verwacht 2 punten [lon,lat] → [lon,lat].
    async function fetchRoadGeometry(coords) {
      // coords: [[lon1,lat1],[lon2,lat2]]
      const a = coords[0], b = coords[1];
      const url = `${OSRM_URL}/${a[0]},${a[1]};${b[0]},${b[1]}?overview=full&geometries=geojson`;
      const res = await fetch(url, { cache: 'no-cache' });
      if (!res.ok) throw new Error('OSRM HTTP '+res.status);
      const data = await res.json();
      const first = data?.routes?.[0]?.geometry;
      if (!first || first.type !== 'LineString') throw new Error('No geometry');
      return first; // {type:'LineString', coordinates:[...]}
    }

    ready(async () => {
      // Wacht tot Leaflet geladen is
      for (let i=0;i<200 && typeof L === 'undefined';i++) { await new Promise(r=>setTimeout(r,25)); }
      if (typeof L === 'undefined') return;

      const map = L.map('map', { scrollWheelZoom: true });

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);

      let bounds = null;
      map.setView([-0.18, -78.47], 6); // fallback Quito

      // 1) ROUTE: laad GeoJSON en render per feature
      try {
        const r = await fetch(ROUTE_URL, { cache: 'no-cache' });
        if (r.ok) {
          const geo = await r.json();

          // We bouwen een lege FeatureCollection en vullen hem met (eventueel) OSRM-gecorrigeerde geometrieën
          const cooked = { type: 'FeatureCollection', features: [] };

          // Sorteer op order als aanwezig (zodat popups netjes zijn)
          const feats = Array.isArray(geo.features) ? [...geo.features] : [];
          feats.sort((a,b) => (a?.properties?.order ?? 0) - (b?.properties?.order ?? 0));

          for (const f of feats) {
            const mode = f?.properties?.mode ?? 'bus';
            const style = styleForMode(mode);

            let geom = f.geometry;

            // Alleen voor motor/bus proberen we OSRM als het een "rechte" 2-punt LineString is
            const canRouteOverRoads =
              (mode === 'motor' || mode === 'bus') &&
              geom?.type === 'LineString' &&
              Array.isArray(geom.coordinates) &&
              geom.coordinates.length === 2 &&
              typeof geom.coordinates[0]?.[0] === 'number';

            if (canRouteOverRoads) {
              try {
                const roadGeom = await fetchRoadGeometry(geom.coordinates);
                geom = roadGeom; // vervang door wegvolgende geometie
              } catch (e) {
                console.warn('OSRM route mislukt, gebruik rechte lijn:', f?.properties?.name, e);
              }
            }

            cooked.features.push({
              type: 'Feature',
              properties: f.properties,
              geometry: geom
            });

            // Direct tekenen (of je kunt 1 L.geoJSON op cooked doen; beide prima)
          }

          const routeLayer = L.geoJSON(cooked, {
            style: (feature) => styleForMode(feature?.properties?.mode),
            onEachFeature: (feature, layer) => {
              const name = feature?.properties?.name ?? 'Traject';
              const mode = feature?.properties?.mode ?? 'onbekend';
              const order = feature?.properties?.order;
              const label = order? `${order}. ${name}` : name;
              layer.bindPopup(`<strong>${label}</strong><br>Modus: ${mode}`);
            }
          }).addTo(map);

          try { bounds = routeLayer.getBounds(); } catch {}
        }
      } catch (e) {
        console.warn("Kon route.geojson niet laden", e);
      }

      // 2) MARKERS
      try {
        const r = await fetch(PLACES_URL, { cache: 'no-cache' });
        if (r.ok) {
          const places = await r.json();
          const markers = [];
          for (const p of places) {
            if (typeof p.lat === 'number' && typeof p.lon === 'number') {
              const m = L.marker([p.lat, p.lon]).addTo(map);
              const title = p.name ? `<strong>${p.name}</strong>` : 'Stop';
              const notes = p.notes ? `<br>${p.notes}` : '';
              m.bindPopup(`${title}${notes}`);
              markers.push(m);
            }
          }
          if (!bounds && markers.length) {
            const group = L.featureGroup(markers);
            bounds = group.getBounds();
          }
        }
      } catch (e) {
        console.warn("Kon places.json niet laden", e);
      }

      // 3) FIT BOUNDS
      if (bounds && bounds.isValid && bounds.isValid()) {
        map.fitBounds(bounds.pad(0.15));
      }
    });
  </script>
</BaseLayout>